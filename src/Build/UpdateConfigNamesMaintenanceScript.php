<?php
declare( strict_types = 1 );

namespace MediaWiki\Extension\Translate\Build;

use MediaWiki\Extension\Translate\Utilities\BaseMaintenanceScript;

/**
 * @since 2025.03
 * @license GPL-2.0-or-later
 * @author Niklas LaxstrÃ¶m
 */
final class UpdateConfigNamesMaintenanceScript extends BaseMaintenanceScript {
	private const TEMPLATE = <<<'TEMPLATE'
<?php
declare( strict_types = 1 );

// This file is automatically generated. Update by running update-config-names script.

namespace MediaWiki\Extension\Translate;

/**
 * Constants for configuration variables for the Translate extension. Similar to MediaWiki core's
 * MainConfigNames class with similar justifications: avoid typos, easier access to documentation
 * and easier navigation.
 *
 * The constant values are a public interface via extension.json, but the constant
 * names are internal to the Translate extension.
 *
 * @license GPL-2.0-or-later
 * @since 2025.05
 * @internal
 */
// phpcs:disable Generic.NamingConventions.UpperCaseConstantName.ClassConstantNotUpperCase
class ConfigNames {
%s
}

TEMPLATE;

	private const CONSTANT_TEMPLATE = <<<'TEMPLATE'
	/**
	 * %s
	 */
	public const %s = '%s';
TEMPLATE;

	public function __construct() {
		parent::__construct();
		$this->addDescription( 'Updates ConfigNames.php' );
	}

	/** @inheritDoc */
	public function execute() {
		$extensionJson = json_decode( file_get_contents( __DIR__ . '/../../extension.json' ), true );
		if ( !is_array( $extensionJson ) ) {
			// If extension.json is not valid, we have bigger problems, but Phan is picky
			$this->fatalError( 'Failed to parse extension.json' );
		}
		$config = $extensionJson['config'];

		$blocks = [];
		foreach ( $config as $name => $details ) {
			$constantName = $this->generateConstantName( $name );
			$description = $this->formatDescription( $details['description'] );
			$blocks[$constantName] = sprintf( self::CONSTANT_TEMPLATE, $description, $constantName, $name ) . "\n";
		}

		$output = sprintf( self::TEMPLATE, implode( "\n", $blocks ) );
		file_put_contents( __DIR__ . '/../ConfigNames.php', $output );
	}

	/**
	 * Generates a constant name from the config key.
	 */
	private function generateConstantName( string $name ): string {
		// Remove any prefix that matches the extension name (if present)
		$name = preg_replace( '/^Translate/', '', $name );
		// Make sure the first character is uppercase
		return ucfirst( $name );
	}

	/**
	 * Formats a description string into a proper PHPDoc comment with line wrapping.
	 * Handles multi-line descriptions and ensures proper indentation.
	 */
	private function formatDescription( string $description ): string {
		// Base indentation without trailing space
		$baseIndent = "\t *";
		// One tab (4) + space (1) + asterisk (1) = 6 characters of base indentation
		$indentWidth = 6;
		// Account for the space after asterisk for content lines
		$maxWidth = 120 - ( $indentWidth + 1 );

		$formattedParagraphs = [];
		$paragraphs = array_map( 'trim', explode( "\n\n", trim( $description ) ) );
		foreach ( $paragraphs as $paragraph ) {
			$wrappedLines = array_map(
				static fn ( $line ) => wordwrap( $line, $maxWidth, "\n$baseIndent " ),
				explode( "\n", $paragraph )
			);
			$formattedParagraphs[] = implode( "\n$baseIndent ", $wrappedLines );
		}

		return implode( "\n$baseIndent\n$baseIndent ", $formattedParagraphs );
	}
}
